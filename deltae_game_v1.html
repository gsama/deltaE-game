<!DOCTYPE html>
<!--
DeltaE Color Game
Version: 0.96
Author: Gautam Samant (gautam.samant [at] gmail.com)
License: MIT License
Source: https://github.com/gsama/deltaE-game

Description:
A color perception game using DeltaE (CIEDE2000) to measure color difference.
Free and Open Source Software (FOSS).

Â© 2025 Gautam Samant. Permission is granted to use, copy, modify, and distribute
this software under the terms of the MIT License.
-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DeltaE Color Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      margin: 0;
      min-height: 100vh;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #e0f7fa, #ede7f6);
      color: #333;
    }
    #hud {
      margin: 20px;
      padding: 15px 20px;
      text-align: center;
      font-size: clamp(14px, 4vw, 20px);
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    }
    #hud h2 {
      margin: 0;
      font-size: 24px;
      color: #3f51b5;
    }
    #board {
      position: relative;
      width: 95vmin;
      height: 95vmin;
      max-width: 600px;
      max-height: 600px;
      background: #fff;
      border: 2px solid #ccc;
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      overflow: hidden;
      touch-action: manipulation;
    }
    #tilesContainer {
      position: absolute;
      inset: 0;
      display: grid;
      width: 100%;
      height: 100%;
    }
    .tile {
      width: 100%;
      height: 100%;
      cursor: pointer;
      box-sizing: border-box;
    }
    .overlay {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.92);
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      z-index: 20;
      padding: 20px;
      box-sizing: border-box;
    }
    .overlay h2 {
      margin: 10px 0;
      font-size: 26px;
      color: #3f51b5;
    }
    .overlay p {
      margin: 6px 0;
      font-size: 18px;
      color: #444;
    }
    #overlay h2 { color: #d32f2f; }
    .overlay button {
      margin-top: 15px;
      padding: 12px 24px;
      font-size: 18px;
      font-weight: bold;
      border: none;
      border-radius: 8px;
      background: #3f51b5;
      color: #fff;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      transition: background 0.3s;
    }
    .overlay button:hover {
      background: #303f9f;
    }
    .contact {
      margin-top: 15px;
      font-size: 14px;
      color: #666;
    }
    #instructions {
      margin: 20px;
      max-width: 600px;
      background: #ffffffcc;
      padding: 15px 20px;
      border-radius: 12px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      font-size: 15px;
      line-height: 1.5;
    }
    #instructions h3 {
      margin-top: 0;
      color: #3f51b5;
    }
    .start-instr {
      max-height: 50%;
      overflow: auto;
      padding: 8px;
      margin-top: 8px;
      background: rgba(255,255,255,0.6);
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    }
  </style>
</head>
<body>
  <div id="hud">
    <h2>DeltaE Color Game</h2>
    <p>Time left: <span id="timer">5</span> | Level: <span id="level">1</span></p>
  </div>

  <div id="board">
    <div id="tilesContainer"></div>

    <div id="overlay" class="overlay">
      <h2>Game Over</h2>
      <p id="finalLevel"></p>
      <p id="finalDelta"></p>
      <p id="jokeLine"></p>
      <button id="restartBtn">Restart</button>
      <p class="contact">gautam.samant [at] gmail.com</p>
    </div>

    <div id="startOverlay" class="overlay">
      <h2>DeltaE Color Game</h2>
      <div class="start-instr">
        <p>Tap the odd tile before the timer runs out.</p>
      </div>
      <button id="startBtn">Start</button>
      <p class="contact">gautam.samant [at] gmail.com</p>
    </div>
  </div>

  <div id="instructions">
    <h3>How to Play</h3>
    <p>A grid of tiles appears. One tile is slightly different in color (Î”E = color difference). Tap the odd one before the timer runs out.</p>
    <p>Each level gets harder: Î”E decreases (colors get closer), and grid size increases.</p>
    <h3>What is Î”E?</h3>
    <p>Î”E (Delta-E) measures the difference between two colors. Î”E &gt; 2 is usually noticeable. Î”E &lt; 1 is almost impossible for most humans to see.</p>
    <p>If you can spot tiles at Î”E &lt; 1, you may have superhuman color vision ðŸ‘€.</p>
  </div>

<script>
// Config & state
let level = 1, deltaE = 10.0, timeLeft = 5, timer, lastBaseColor, lastOddColor;
const jokes = ["Close, but no chroma!", "Hue missed it!", "DeltaE = Definitely Ended!", "Perception is tricky!", "Colors played you this time!"];

// DOM elements
const [tilesContainer, timerDisplay, levelDisplay, overlay, startOverlay, finalLevel, finalDelta, jokeLine] = 
  ['tilesContainer', 'timer', 'level', 'overlay', 'startOverlay', 'finalLevel', 'finalDelta', 'jokeLine']
  .map(id => document.getElementById(id));

// Color math
const srgbToLinear = c => (c /= 255) <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
const rgbToXyz = (r,g,b) => {
  const [R,G,B] = [r,g,b].map(srgbToLinear);
  return {x: R*0.4124564 + G*0.3575761 + B*0.1804375, y: R*0.2126729 + G*0.7151522 + B*0.0721750, z: R*0.0193339 + G*0.1191920 + B*0.9503041};
};
const fLab = t => t > Math.pow(6/29, 3) ? Math.cbrt(t) : (t*(29/6)*(29/6)/3 + 4/29);
const xyzToLab = (x,y,z) => {
  const [fx,fy,fz] = [x/0.95047, y, z/1.08883].map(fLab);
  return {L: 116 * fy - 16, a: 500 * (fx - fy), b: 200 * (fy - fz)};
};

// CIEDE2000
function ciede2000(lab1, lab2) {
  const {L:L1,a:a1,b:b1} = lab1, {L:L2,a:a2,b:b2} = lab2;
  const C1 = Math.hypot(a1,b1), C2 = Math.hypot(a2,b2), Cbar = (C1+C2)/2;
  const G = 0.5*(1-Math.sqrt(Math.pow(Cbar,7)/(Math.pow(Cbar,7)+Math.pow(25,7))));
  const [a1p,a2p] = [(1+G)*a1, (1+G)*a2];
  const [C1p,C2p] = [Math.hypot(a1p,b1), Math.hypot(a2p,b2)];
  const [h1p,h2p] = [Math.atan2(b1,a1p), Math.atan2(b2,a2p)];
  const [dLp,dCp] = [L2-L1, C2p-C1p];
  let dhp = h2p-h1p;
  if (C1p*C2p === 0) dhp = 0;
  else if (dhp > Math.PI) dhp -= 2*Math.PI;
  else if (dhp < -Math.PI) dhp += 2*Math.PI;
  const dHp = 2 * Math.sqrt(C1p*C2p) * Math.sin(dhp/2);
  const [Lbar,Cbarp] = [(L1+L2)/2, (C1p+C2p)/2];
  let hbarp = (h1p + h2p) / 2;
  if (C1p*C2p !== 0 && Math.abs(h1p - h2p) > Math.PI) hbarp += Math.PI;
  const T = 1 - 0.17*Math.cos(hbarp-Math.PI/6) + 0.24*Math.cos(2*hbarp) + 0.32*Math.cos(3*hbarp+Math.PI/30) - 0.20*Math.cos(4*hbarp-7*Math.PI/9);
  const Sl = 1 + (0.015 * Math.pow(Lbar - 50, 2)) / Math.sqrt(20 + Math.pow(Lbar - 50, 2));
  const [Sc,Sh] = [1 + 0.045 * Cbarp, 1 + 0.015 * Cbarp * T];
  const delTheta = Math.PI/6 * Math.exp(-Math.pow((hbarp*180/Math.PI - 275) / 25, 2));
  const Rc = 2 * Math.sqrt(Math.pow(Cbarp,7) / (Math.pow(Cbarp,7) + Math.pow(25,7)));
  const Rt = -Rc * Math.sin(2 * delTheta);
  return Math.sqrt(Math.pow(dLp/Sl, 2) + Math.pow(dCp/Sc, 2) + Math.pow(dHp/Sh, 2) + Rt * (dCp/Sc) * (dHp/Sh));
}

// Color conversion helpers
const linearToSrgb = c => c <= 0.0031308 ? 12.92 * c : 1.055 * Math.pow(c, 1/2.4) - 0.055;
const xyzToLinearRgb = (x,y,z) => ({
  R: 3.2404542*x - 1.5371385*y - 0.4985314*z,
  G: -0.9692660*x + 1.8760108*y + 0.0415560*z,
  B: 0.0556434*x - 0.2040259*y + 1.0572252*z
});
const linearRgbToSrgb255 = (R,G,B) => ({
  r: Math.round(Math.min(1, Math.max(0, linearToSrgb(R))) * 255),
  g: Math.round(Math.min(1, Math.max(0, linearToSrgb(G))) * 255),
  b: Math.round(Math.min(1, Math.max(0, linearToSrgb(B))) * 255)
});
const labToXyz = (L,a,b) => {
  const [fy,fx,fz] = [(L+16)/116].concat([a/500, -b/200].map(d => (L+16)/116 + d));
  const EPS = Math.pow(6/29, 3);
  const [xr,yr,zr] = [fx,fy,fz].map(f => Math.pow(f,3) > EPS ? Math.pow(f,3) : (116*f-16)/903.3);
  return {x: xr*0.95047, y: yr, z: zr*1.08883};
};
const labToRgb255 = (L,a,b) => {
  const xyz = labToXyz(L,a,b);
  const linear = xyzToLinearRgb(xyz.x, xyz.y, xyz.z);
  return linearRgbToSrgb255(linear.R, linear.G, linear.B);
};
const isInGamut = rgb => rgb.r >= 0 && rgb.r <= 255 && rgb.g >= 0 && rgb.g <= 255 && rgb.b >= 0 && rgb.b <= 255;

// Color solver
function findColorAtDeltaE(baseRgbStr, targetDeltaE) {
  if (targetDeltaE <= 1e-6) return baseRgbStr;
  const baseNums = baseRgbStr.match(/\d+/g).map(Number);
  const baseLab = xyzToLab(...Object.values(rgbToXyz(...baseNums)));
  let best = {rgbStr: null, err: Infinity};
  const Lrange = Math.max(2.5, targetDeltaE * 0.35);
  
  for (let li = 0; li < 3; li++) {
    const dL = -Lrange + (2 * Lrange) * (li / 2);
    for (let deg = 0; deg < 360; deg += 12) {
      const [ux, uy] = [Math.cos(deg * Math.PI / 180), Math.sin(deg * Math.PI / 180)];
      let [low, high] = [0, Math.max(targetDeltaE * 4, targetDeltaE + 10)];
      
      for (let iter = 0; iter < 20; iter++) {
        const m = (low + high) / 2;
        const la = {L: baseLab.L + dL, a: baseLab.a + m * ux, b: baseLab.b + m * uy};
        const ach = ciede2000(baseLab, la);
        const rgbObj = labToRgb255(la.L, la.a, la.b);
        
        if (isInGamut(rgbObj) && Math.abs(ach - targetDeltaE) < best.err) {
          best = {rgbStr: `rgb(${rgbObj.r},${rgbObj.g},${rgbObj.b})`, err: Math.abs(ach - targetDeltaE)};
          if (best.err <= 0.14) return best.rgbStr;
        }
        
        if (ach < targetDeltaE) low = m; else high = m;
      }
    }
  }
  
  if (best.rgbStr && best.err <= 0.6) return best.rgbStr;
  const [r,g,b] = baseRgbStr.match(/\d+/g).map(Number);
  return `rgb(${Math.min(255, r + Math.round(targetDeltaE))},${Math.min(255, g + Math.round(targetDeltaE))},${Math.min(255, b + Math.round(targetDeltaE))})`;
}

const randomColor = () => `rgb(${Math.floor(Math.random()*200)},${Math.floor(Math.random()*200)},${Math.floor(Math.random()*200)})`;

// Game logic
function startGame() {
  level = 1; deltaE = 10.0;
  overlay.style.display = startOverlay.style.display = 'none';
  tilesContainer.innerHTML = '';
  levelDisplay.textContent = level;
  resetTimer();
  generateBoard();
}

function resetTimer() {
  clearInterval(timer);
  timeLeft = 5;
  timerDisplay.textContent = timeLeft;
  timer = setInterval(() => {
    if (--timeLeft <= 0) { clearInterval(timer); showGameOver(); }
    else timerDisplay.textContent = timeLeft;
  }, 1000);
}

function generateBoard() {
  const size = Math.min(10, 3 + Math.floor((level - 1)/2));
  tilesContainer.style.gridTemplate = `repeat(${size}, 1fr) / repeat(${size}, 1fr)`;
  tilesContainer.innerHTML = '';

  const baseColor = randomColor();
  const diffColor = findColorAtDeltaE(baseColor, deltaE);
  [lastBaseColor, lastOddColor] = [baseColor, diffColor];

  const specialIndex = Math.floor(Math.random() * size * size);
  for (let i = 0; i < size * size; i++) {
    const tile = document.createElement('div');
    tile.className = 'tile';
    tile.style.backgroundColor = i === specialIndex ? diffColor : baseColor;
    tile.onclick = () => {
      if (i === specialIndex) {
        level++; deltaE = Math.max(0.0, deltaE * 0.95);
        levelDisplay.textContent = level;
        generateBoard(); resetTimer();
      } else { clearInterval(timer); showGameOver(); }
    };
    tilesContainer.appendChild(tile);
  }
}

function showGameOver() {
  if (lastBaseColor && lastOddColor) {
    const [lab1, lab2] = [lastBaseColor, lastOddColor].map(c => {
      const nums = c.match(/\d+/g).map(Number);
      return xyzToLab(...Object.values(rgbToXyz(...nums)));
    });
    finalDelta.textContent = 'Actual Î”E: ' + ciede2000(lab1, lab2).toFixed(2);
  } else {
    finalDelta.textContent = 'Actual Î”E: -';
  }
  finalLevel.textContent = 'Your Level: ' + level;
  jokeLine.textContent = jokes[Math.floor(Math.random() * jokes.length)];
  overlay.style.display = 'flex';
}

// Event listeners
document.getElementById('restartBtn').onclick = () => {
  overlay.style.display = 'none';
  startOverlay.style.display = 'flex';
};
document.getElementById('startBtn').onclick = startGame;

// Initialize
startOverlay.style.display = 'flex';
</script>
</body>
</html>